"""
This type stub file was generated by pyright.
"""

import torch
from argparse import Namespace
from typing import Any, Callable, Dict, List
from fairseq import utils
from fairseq.dataclass import FairseqDataclass
from omegaconf import DictConfig

logger = ...
class StatefulContainer:
    def __init__(self) -> None:
        ...
    
    def add_factory(self, name, factory: Callable[[], Any]): # -> None:
        ...
    
    def merge_state_dict(self, state_dict: Dict[str, Any]): # -> None:
        ...
    
    @property
    def state_dict(self) -> Dict[str, Any]:
        ...
    
    def __getattr__(self, name):
        ...
    


class FairseqTask:
    """
    Tasks store dictionaries and provide helpers for loading/iterating over
    Datasets, initializing the Model/Criterion and calculating the loss.

    Tasks have limited statefulness. In particular, state that needs to be
    saved to/loaded from checkpoints needs to be stored in the `self.state`
    :class:`StatefulContainer` object. For example::

        self.state.add_factory("dictionary", self.load_dictionary)
        print(self.state.dictionary)  # calls self.load_dictionary()

    This is necessary so that when loading checkpoints, we can properly
    recreate the task state after initializing the task instance.
    """
    @classmethod
    def add_args(cls, parser): # -> None:
        """Add task-specific arguments to the parser."""
        ...
    
    @staticmethod
    def logging_outputs_can_be_summed(criterion) -> bool:
        """
        Whether the logging outputs returned by `train_step` and `valid_step` can
        be summed across workers prior to calling `aggregate_logging_outputs`.
        Setting this to True will improves distributed training speed.
        """
        ...
    
    def __init__(self, cfg: FairseqDataclass, **kwargs) -> None:
        ...
    
    @classmethod
    def load_dictionary(cls, filename): # -> Dictionary:
        """Load the dictionary from the filename

        Args:
            filename (str): the filename
        """
        ...
    
    @classmethod
    def build_dictionary(cls, filenames, workers=..., threshold=..., nwords=..., padding_factor=...): # -> Dictionary:
        """Build the dictionary

        Args:
            filenames (list): list of filenames
            workers (int): number of concurrent workers
            threshold (int): defines the minimum word count
            nwords (int): defines the total number of words in the final dictionary,
                including special symbols
            padding_factor (int): can be used to pad the dictionary size to be a
                multiple of 8, which is important on some hardware (e.g., Nvidia
                Tensor Cores).
        """
        ...
    
    @classmethod
    def setup_task(cls, cfg: DictConfig, **kwargs): # -> Self:
        """Setup the task (e.g., load dictionaries).

        Args:
            cfg (omegaconf.DictConfig): parsed command-line arguments
        """
        ...
    
    def has_sharded_data(self, split): # -> bool:
        ...
    
    def load_dataset(self, split: str, combine: bool = ..., task_cfg: FairseqDataclass = ..., **kwargs):
        """Load a given dataset split.

        Args:
            split (str): name of the split (e.g., train, valid, test)
            combine (bool): combines a split segmented into pieces into one dataset
            task_cfg (FairseqDataclass): optional task configuration stored in the checkpoint that can be used
                                         to load datasets
        """
        ...
    
    def dataset(self, split):
        """
        Return a loaded dataset split.

        Args:
            split (str): name of the split (e.g., train, valid, test)

        Returns:
            a :class:`~fairseq.data.FairseqDataset` corresponding to *split*
        """
        ...
    
    def filter_indices_by_size(self, indices, dataset, max_positions=..., ignore_invalid_inputs=...):
        """
        Filter examples that are too large

        Args:
            indices (np.array): original array of sample indices
            dataset (~fairseq.data.FairseqDataset): dataset to batch
            max_positions (optional): max sentence length supported by the
                model (default: None).
            ignore_invalid_inputs (bool, optional): don't raise Exception for
                sentences that are too long (default: False).
        Returns:
            np.array: array of filtered sample indices
        """
        ...
    
    def can_reuse_epoch_itr(self, dataset): # -> Any | bool:
        ...
    
    def get_batch_iterator(self, dataset, max_tokens=..., max_sentences=..., max_positions=..., ignore_invalid_inputs=..., required_batch_size_multiple=..., seed=..., num_shards=..., shard_id=..., num_workers=..., epoch=..., data_buffer_size=..., disable_iterator_cache=..., skip_remainder_batch=..., grouped_shuffling=..., update_epoch_batch_itr=...): # -> EpochBatchIterator:
        """
        Get an iterator that yields batches of data from the given dataset.

        Args:
            dataset (~fairseq.data.FairseqDataset): dataset to batch
            max_tokens (int, optional): max number of tokens in each batch
                (default: None).
            max_sentences (int, optional): max number of sentences in each
                batch (default: None).
            max_positions (optional): max sentence length supported by the
                model (default: None).
            ignore_invalid_inputs (bool, optional): don't raise Exception for
                sentences that are too long (default: False).
            required_batch_size_multiple (int, optional): require batch size to
                be a multiple of N (default: 1).
            seed (int, optional): seed for random number generator for
                reproducibility (default: 1).
            num_shards (int, optional): shard the data iterator into N
                shards (default: 1).
            shard_id (int, optional): which shard of the data iterator to
                return (default: 0).
            num_workers (int, optional): how many subprocesses to use for data
                loading. 0 means the data will be loaded in the main process
                (default: 0).
            epoch (int, optional): the epoch to start the iterator from
                (default: 1).
            data_buffer_size (int, optional): number of batches to
                preload (default: 0).
            disable_iterator_cache (bool, optional): don't cache the
                EpochBatchIterator (ignores `FairseqTask::can_reuse_epoch_itr`)
                (default: False).
            skip_remainder_batch (bool, optional): if set, discard the last
                batch in each training epoch, as the last batch is often smaller than
                    local_batch_size * distributed_word_size (default: ``True``).
            grouped_shuffling (bool, optional): group batches with each groups
                containing num_shards batches and shuffle groups. Reduces difference
                between sequence lengths among workers for batches sorted by length.
            update_epoch_batch_itr (bool optional): if true then donot use the cached
                batch iterator for the epoch

        Returns:
            ~fairseq.iterators.EpochBatchIterator: a batched iterator over the
                given dataset split
        """
        ...
    
    def build_model(self, cfg: FairseqDataclass, from_checkpoint=...):
        """
        Build the :class:`~fairseq.models.BaseFairseqModel` instance for this
        task.

        Args:
            cfg (FairseqDataclass): configuration object

        Returns:
            a :class:`~fairseq.models.BaseFairseqModel` instance
        """
        ...
    
    def build_criterion(self, cfg: DictConfig): # -> Any | None:
        """
        Build the :class:`~fairseq.criterions.FairseqCriterion` instance for
        this task.

        Args:
            cfg (omegaconf.DictConfig): configration object

        Returns:
            a :class:`~fairseq.criterions.FairseqCriterion` instance
        """
        ...
    
    def build_generator(self, models, args, seq_gen_cls=..., extra_gen_cls_kwargs=..., prefix_allowed_tokens_fn=...): # -> SequenceScorer | SequenceGenerator | SequenceGeneratorWithAlignment:
        """
        Build a :class:`~fairseq.SequenceGenerator` instance for this
        task.

        Args:
            models (List[~fairseq.models.FairseqModel]): ensemble of models
            args (fairseq.dataclass.configs.GenerationConfig):
                configuration object (dataclass) for generation
            extra_gen_cls_kwargs (Dict[str, Any]): extra options to pass
                through to SequenceGenerator
            prefix_allowed_tokens_fn (Callable[[int, torch.Tensor], List[int]]):
                If provided, this function constrains the beam search to
                allowed tokens only at each step. The provided function
                should take 2 arguments: the batch ID (`batch_id: int`)
                and a unidimensional tensor of token ids (`inputs_ids:
                torch.Tensor`). It has to return a `List[int]` with the
                allowed tokens for the next generation step conditioned
                on the previously generated tokens (`inputs_ids`) and
                the batch ID (`batch_id`). This argument is useful for
                constrained generation conditioned on the prefix, as
                described in "Autoregressive Entity Retrieval"
                (https://arxiv.org/abs/2010.00904) and
                https://github.com/facebookresearch/GENRE.
        """
        ...
    
    def train_step(self, sample, model, criterion, optimizer, update_num, ignore_grad=...): # -> tuple[Any, Any, Any]:
        """
        Do forward and backward, and return the loss as computed by *criterion*
        for the given *model* and *sample*.

        Args:
            sample (dict): the mini-batch. The format is defined by the
                :class:`~fairseq.data.FairseqDataset`.
            model (~fairseq.models.BaseFairseqModel): the model
            criterion (~fairseq.criterions.FairseqCriterion): the criterion
            optimizer (~fairseq.optim.FairseqOptimizer): the optimizer
            update_num (int): the current update
            ignore_grad (bool): multiply loss by 0 if this is set to True

        Returns:
            tuple:
                - the loss
                - the sample size, which is used as the denominator for the
                  gradient
                - logging outputs to display while training
        """
        ...
    
    def valid_step(self, sample, model, criterion): # -> tuple[Any, Any, Any]:
        ...
    
    def optimizer_step(self, optimizer, model, update_num): # -> None:
        ...
    
    def build_dataset_for_inference(self, src_tokens: List[torch.Tensor], src_lengths: List[int], **kwargs) -> torch.utils.data.Dataset:
        ...
    
    def inference_step(self, generator, models, sample, prefix_tokens=..., constraints=...):
        ...
    
    def begin_epoch(self, epoch, model): # -> None:
        """Hook function called before the start of each epoch."""
        ...
    
    def begin_valid_epoch(self, epoch, model): # -> None:
        """Hook function called before the start of each validation epoch."""
        ...
    
    def aggregate_logging_outputs(self, logging_outputs, criterion): # -> Dict[str, float]:
        """[deprecated] Aggregate logging outputs from data parallel training."""
        ...
    
    def reduce_metrics(self, logging_outputs, criterion): # -> None:
        """Aggregate logging outputs from data parallel training."""
        ...
    
    def state_dict(self): # -> Dict[str, Any] | dict[Any, Any]:
        ...
    
    def load_state_dict(self, state_dict: Dict[str, Any]): # -> None:
        ...
    
    def max_positions(self): # -> None:
        """Return the max input length allowed by the task."""
        ...
    
    @property
    def source_dictionary(self):
        """Return the source :class:`~fairseq.data.Dictionary` (if applicable
        for this task)."""
        ...
    
    @property
    def target_dictionary(self):
        """Return the target :class:`~fairseq.data.Dictionary` (if applicable
        for this task)."""
        ...
    
    def build_tokenizer(self, args): # -> Any | None:
        """Build the pre-tokenizer for this task."""
        ...
    
    def build_bpe(self, args): # -> Any | None:
        """Build the tokenizer for this task."""
        ...
    
    def get_interactive_tokens_and_lengths(self, lines, encode_fn): # -> tuple[list[Any], list[Any]]:
        ...
    


class LegacyFairseqTask(FairseqTask):
    def __init__(self, args: Namespace) -> None:
        ...
    
    @classmethod
    def setup_task(cls, args: Namespace, **kwargs): # -> Self:
        """Setup the task (e.g., load dictionaries).

        Args:
            args (argparse.Namespace): parsed command-line arguments
        """
        ...
    
    def has_sharded_data(self, split): # -> bool:
        ...
    
    def build_model(self, args: Namespace, from_checkpoint=...):
        """
        Build the :class:`~fairseq.models.BaseFairseqModel` instance for this
        task.

        Args:
            args (argparse.Namespace): parsed command-line arguments

        Returns:
            a :class:`~fairseq.models.BaseFairseqModel` instance
        """
        ...
    
    def build_criterion(self, args: Namespace): # -> Any | None:
        """
        Build the :class:`~fairseq.criterions.FairseqCriterion` instance for
        this task.

        Args:
            args (argparse.Namespace): parsed command-line arguments

        Returns:
            a :class:`~fairseq.criterions.FairseqCriterion` instance
        """
        ...
    


