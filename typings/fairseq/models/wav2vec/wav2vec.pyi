"""
This type stub file was generated by pyright.
"""

import torch.nn as nn
from dataclasses import dataclass
from typing import Optional, Tuple
from fairseq.dataclass import FairseqDataclass
from fairseq.models import BaseFairseqModel, register_model
from fairseq.tasks import FairseqTask

logger = ...
AGGREGATOR_CHOICES = ...
PROJECT_FEATURES_CHOICES = ...
ACTIVATION_CHOICES = ...
VQ_TYPE_CHOICES = ...
@dataclass
class Wav2VecConfig(FairseqDataclass):
    prediction_steps: int = ...
    sample_distance: Optional[int] = ...
    cross_sample_negatives: int = ...
    num_negatives: int = ...
    conv_feature_layers: str = ...
    conv_aggregator_layers: str = ...
    dropout: float = ...
    dropout_features: float = ...
    dropout_agg: float = ...
    aggregator: AGGREGATOR_CHOICES = ...
    gru_dim: int = ...
    no_conv_bias: bool = ...
    agg_zero_pad: bool = ...
    skip_connections_feat: bool = ...
    skip_connections_agg: bool = ...
    residual_scale: float = ...
    log_compression: bool = ...
    balanced_classes: bool = ...
    project_features: PROJECT_FEATURES_CHOICES = ...
    non_affine_group_norm: bool = ...
    offset: str = ...
    activation: ACTIVATION_CHOICES = ...
    vq_type: VQ_TYPE_CHOICES = ...
    vq_vars: int = ...
    vq_groups: int = ...
    vq_dim: int = ...
    vq_depth: int = ...
    combine_groups: bool = ...
    vq_temp: Tuple[float, float, float] = ...
    vq_gamma: float = ...
    infonce: bool = ...


@register_model("wav2vec", dataclass=Wav2VecConfig)
class Wav2VecModel(BaseFairseqModel):
    @classmethod
    def build_model(cls, cfg: Wav2VecConfig, task: FairseqTask): # -> BaseFairseqModel:
        """Build a new model instance."""
        ...
    
    def __init__(self, cfg: Wav2VecConfig) -> None:
        ...
    
    def forward(self, source): # -> dict[Any, Any]:
        ...
    
    def upgrade_state_dict_named(self, state_dict, name): # -> None:
        ...
    
    def max_positions(self): # -> int:
        """Maximum length supported by the model."""
        ...
    
    def get_logits(self, net_output):
        ...
    
    def get_targets(self, sample, net_output):
        ...
    
    def get_target_weights(self, targets, net_output): # -> None:
        ...
    
    def get_extra_losses(self, net_output): # -> None:
        ...
    


def norm_block(is_layer_norm, dim, affine=...): # -> Sequential | Fp32GroupNorm:
    ...

class ConvFeatureExtractionModel(nn.Module):
    def __init__(self, conv_layers, dropout, log_compression, skip_connections, residual_scale, non_affine_group_norm, activation) -> None:
        ...
    
    def forward(self, x): # -> Any:
        ...
    


class ZeroPad1d(nn.Module):
    def __init__(self, pad_left, pad_right) -> None:
        ...
    
    def forward(self, x): # -> Tensor:
        ...
    


class ConvAggegator(nn.Module):
    def __init__(self, conv_layers, embed, dropout, skip_connections, residual_scale, non_affine_group_norm, conv_bias, zero_pad, activation) -> None:
        ...
    
    def forward(self, x): # -> Any:
        ...
    


class Wav2VecPredictionsModel(nn.Module):
    def __init__(self, in_dim, out_dim, prediction_steps, n_negatives, cross_sample_negatives, sample_distance, dropout, offset, balanced_classes, infonce) -> None:
        ...
    
    def sample_negatives(self, y):
        ...
    
    def forward(self, x, y): # -> tuple[Any, Any | Tensor | tuple[Any | Tensor, Tensor]]:
        ...
    


