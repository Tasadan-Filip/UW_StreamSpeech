"""
This type stub file was generated by pyright.
"""

import typing as tp
from dataclasses import dataclass
from bitarray import bitarray
from fairseq.data import Dictionary

BLOCKSIZE = ...
class HuffmanCoder:
    def __init__(self, root: HuffmanNode, bos=..., pad=..., eos=..., unk=...) -> None:
        ...
    
    def encode(self, iter: tp.List[str]) -> bytes:
        """
        encode a list of tokens a return bytes. We use bitpadding to make sure the encoded bits fit in bytes.
        """
        ...
    
    def decode(self, bits: bytes) -> tp.Iterator[HuffmanNode]:
        """
        take bitpadded bytes and decode it to a set of leaves. You can then use each node to find the symbol/id
        """
        ...
    
    def get_code(self, symbol: str) -> tp.Optional[bitarray]:
        ...
    
    def get_node(self, symbol: str) -> HuffmanNode:
        ...
    
    @classmethod
    def from_file(cls, filename: str, bos=..., pad=..., eos=..., unk=...) -> HuffmanCoder:
        ...
    
    def to_file(self, filename, sep=...): # -> None:
        ...
    
    def __iter__(self): # -> Generator[HuffmanNode, Any, None]:
        ...
    
    def merge(self, other_coder: HuffmanCoder) -> HuffmanCoder:
        ...
    
    def __eq__(self, other: HuffmanCoder) -> bool:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __contains__(self, sym: str) -> bool:
        ...
    
    def to_dictionary(self) -> Dictionary:
        ...
    


@dataclass
class HuffmanNode:
    """
    a node in a Huffman tree
    """
    id: int
    count: int
    symbol: tp.Optional[str] = ...
    left: tp.Optional[HuffmanNode] = ...
    right: tp.Optional[HuffmanNode] = ...
    code: tp.Optional[bitarray] = ...
    def is_leaf(self) -> bool:
        ...
    
    def code_table(self, prefix: tp.Optional[bitarray] = ...) -> tp.Dict[str, HuffmanNode]:
        ...
    
    def decode(self, bits: bitarray) -> tp.Iterator[HuffmanNode]:
        ...
    


class HuffmanCodeBuilder:
    """
    build a dictionary with occurence count and then build the Huffman code for it.
    """
    def __init__(self) -> None:
        ...
    
    def add_symbols(self, *syms) -> None:
        ...
    
    def increment(self, symbol: str, cnt: int) -> None:
        ...
    
    @classmethod
    def from_file(cls, filename): # -> Self:
        ...
    
    def to_file(self, filename, sep=...): # -> None:
        ...
    
    def __add__(self, c: HuffmanCodeBuilder) -> HuffmanCodeBuilder:
        ...
    
    def build_code(self, bos=..., pad=..., eos=..., unk=...) -> HuffmanCoder:
        ...
    


