"""
This type stub file was generated by pyright.
"""

import subprocess
from typing import Hashable

PYARROW_AVAILABLE = ...
class PlasmaArray:
    """
    Wrapper around numpy arrays that automatically moves the data to shared
    memory upon serialization. This is particularly helpful when passing numpy
    arrays through multiprocessing, so that data is not unnecessarily
    duplicated or pickled.
    """
    def __init__(self, array) -> None:
        ...
    
    @property
    def plasma(self): # -> Any | None:
        ...
    
    def start_server(self): # -> None:
        ...
    
    @property
    def client(self):
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        """Called on pickle load"""
        ...
    
    def __setstate__(self, state): # -> None:
        """Called on pickle save"""
        ...
    
    def __del__(self): # -> None:
        ...
    


DEFAULT_PLASMA_PATH = ...
class PlasmaView:
    """Interface to write and read from shared memory. Whereas PlasmaArray writes to plasma on serialization,
    PlasmaView writes to shared memory on instantiation."""
    def __init__(self, array, split_path: str, hash_data: Hashable, plasma_path=...) -> None:
        """
        Args:
            array: numpy array to store. This can be read with ``PlasmaView().array``
            split_path: the path whence the data was read, used for hashing
            hash_data: other metadata about the array that can be used to create a unique key.
                as of writing, the 3 callers in ``TokenBlockDataset`` use::

                    hash_data = ((block_size, document_sep_len, str(break_mode), len(dataset)), 0|1|2)


        """
        ...
    
    @property
    def client(self):
        ...
    
    @property
    def array(self):
        """Fetch a read only view of an np.array, stored in plasma."""
        ...
    
    @staticmethod
    def get_object_id(split_path: str, hash_data: Hashable):
        """Returns plasma.ObjectID from hashing split_path and object_num."""
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        """Called on pickle save"""
        ...
    
    def __setstate__(self, state): # -> None:
        """Called on pickle load"""
        ...
    
    def __del__(self): # -> None:
        ...
    
    def disconnect(self): # -> None:
        ...
    
    def __len__(self): # -> int:
        """Save reads by caching len"""
        ...
    


GB100 = ...
class PlasmaStore:
    def __init__(self, path=..., nbytes: int = ...) -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    @staticmethod
    def start(path=..., nbytes: int = ...) -> subprocess.Popen:
        ...
    


