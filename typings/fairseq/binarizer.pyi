"""
This type stub file was generated by pyright.
"""

import typing as tp
import torch
from abc import ABC, abstractmethod
from collections import Counter
from dataclasses import dataclass
from fairseq.data import Dictionary

logger = ...
@dataclass
class BinarizeSummary:
    """
    Keep track of what's going on in the binarizer
    """
    num_seq: int = ...
    replaced: tp.Optional[Counter] = ...
    num_tok: int = ...
    @property
    def num_replaced(self) -> int:
        ...
    
    @property
    def replaced_percent(self) -> float:
        ...
    
    def __str__(self) -> str:
        ...
    
    def merge(self, other: BinarizeSummary): # -> None:
        ...
    


class Binarizer(ABC):
    """
    a binarizer describes how to take a string and build a tensor out of it
    """
    @abstractmethod
    def binarize_line(self, line: str, summary: BinarizeSummary) -> torch.IntTensor:
        ...
    


class FileBinarizer:
    """
    An file binarizer can take a file, tokenize it, and binarize each line to a tensor
    """
    @classmethod
    def multiprocess_dataset(cls, input_file: str, dataset_impl: str, binarizer: Binarizer, output_prefix: str, vocab_size=..., num_workers=...) -> BinarizeSummary:
        ...
    


class VocabularyDatasetBinarizer(Binarizer):
    """
    Takes a Dictionary/Vocabulary, assign ids to each
    token using the dictionary encode_line function.
    """
    def __init__(self, dict: Dictionary, tokenize: tp.Callable[[str], tp.List[str]] = ..., append_eos: bool = ..., reverse_order: bool = ..., already_numberized: bool = ...) -> None:
        ...
    
    def binarize_line(self, line: str, summary: BinarizeSummary): # -> IntTensor:
        ...
    


class AlignmentDatasetBinarizer(Binarizer):
    """
    binarize by parsing a set of alignments and packing
    them in a tensor (see utils.parse_alignment)
    """
    def __init__(self, alignment_parser: tp.Callable[[str], torch.IntTensor]) -> None:
        ...
    
    def binarize_line(self, line: str, summary: BinarizeSummary): # -> IntTensor:
        ...
    


class LegacyBinarizer:
    @classmethod
    def binarize(cls, filename: str, dico: Dictionary, consumer: tp.Callable[[torch.IntTensor], None], tokenize: tp.Callable[[str], tp.List[str]] = ..., append_eos: bool = ..., reverse_order: bool = ..., offset: int = ..., end: int = ..., already_numberized: bool = ...) -> tp.Dict[str, int]:
        ...
    
    @classmethod
    def binarize_alignments(cls, filename: str, alignment_parser: tp.Callable[[str], torch.IntTensor], consumer: tp.Callable[[torch.IntTensor], None], offset: int = ..., end: int = ...) -> tp.Dict[str, int]:
        ...
    


